#version 450

layout(local_size_x = 32) in; // TODO set local size from rust code

layout(set = 0, binding = 0) uniform ComputationConstants {
    uint boids_count;
    float dt;
};

struct BoidData {
    vec4 pos;
    vec4 vel;
    vec4 wander;
    mat4 model;
};

layout(set = 0, binding = 1) buffer SrcBoidData {
    BoidData boids[];
} src_boid_data;

layout(set = 0, binding = 2) buffer DstBoidData {
    BoidData boids[];
} dst_boid_data;

const float PI = 3.141592653589793;

const float MAX_VELOCITY = 5.0;

const float WEIGHT = 10.0;
const float BODY_RADIUS = 3.5;
const float VISIBILITY_RADIUS = 7.0;
const float DAMPING_DISTANCE = VISIBILITY_RADIUS * 0.75;

vec3 safe_normalize(vec3 v) {
    float l = length(v);

    if (l == 0.0) {
        return vec3(0.0);
    }

    return v / l;
}

vec3 limit(vec3 v, float limit) {
    float l = length(v);

    if (l > 0.0) {
        return safe_normalize(v) * min(l, limit);
    }

    return v;
}

float random(vec3 st) {
    return fract(
        sin(
            dot(
                st,
                vec3(12.9898, 78.233, 7.37562)
            )
        ) * 43758.5453123
    );
}

vec3 damp(vec3 desired_vel, float d) {
    if (d <= DAMPING_DISTANCE) {
        return desired_vel * (d / DAMPING_DISTANCE);
    }

    return desired_vel;
}

bool is_visible(BoidData self, vec3 other_pos) {
    vec3 vec_to_other = self.pos.xyz - other_pos;
    float vec_to_other_length = length(vec_to_other);

    float angle = acos(dot(self.vel.xyz, vec_to_other) / length(self.vel.xyz) * vec_to_other_length);

    float distance = vec_to_other_length - 2.0 * BODY_RADIUS;

    return distance > 0.0 && distance < VISIBILITY_RADIUS && angle < (135.0 * PI / 180.0);
}

vec3 average(vec3 v, uint neighbors) {
    if (neighbors > 0) {
        return v / neighbors;
    }

    return v;
}

vec3 seek(uint current, vec3 target) {
    BoidData self = src_boid_data.boids[current];

    vec3 desired_pos = target - self.pos.xyz;
    float distance = length(desired_pos);
    vec3 desired_vel = safe_normalize(desired_pos) * MAX_VELOCITY;
    return desired_vel - self.vel.xyz;
}

vec3 wander(uint current) {
    const float WANDER_CIRCLE_DISTANCE = 1.0;
    const float WANDER_CHANGEABLE_ANGLE = PI / 2.0;
    const float WANDER_HALF_CHANGEABLE_ANGLE = WANDER_CHANGEABLE_ANGLE / 2.0;
    const float WANDER_CIRCLE_RADIUS = 2.5;

    BoidData self = src_boid_data.boids[current];
    vec3 vel = safe_normalize(self.vel.xyz);

    vec3 circle_center = vel * WANDER_CIRCLE_DISTANCE;
    float angle = WANDER_CHANGEABLE_ANGLE * random(vel) - WANDER_HALF_CHANGEABLE_ANGLE;

    float x = random(vec3(vel.x * angle, vel.y, vel.z)) * 2.0 - 1.0;
    float y = random(vec3(vel.x, vel.y * angle, vel.z)) * 2.0 - 1.0;
    float z = random(vec3(vel.x, vel.y, vel.z * angle)) * 2.0 - 1.0;
    vec3 circle = safe_normalize(vec3(x, y, z)) * WANDER_CIRCLE_RADIUS;

    vec3 wander = self.wander.xyz + circle_center + circle;
    dst_boid_data.boids[current].wander.xyz = safe_normalize(wander);

    return wander;
}

vec3 align(uint current) {
    vec3 steering = vec3(0.0);
    uint neighbors = 0;

    BoidData self = src_boid_data.boids[current];

    for (int i = 0; i < boids_count; i++) {
        BoidData other = src_boid_data.boids[i];

        if (i == current || !is_visible(self, other.pos.xyz)) {continue;}
        neighbors += 1;

        steering += other.vel.xyz;
    }

    steering = average(steering, neighbors);

    return steering;
}

vec3 cohesion(uint current) {
    vec3 steering = vec3(0.0);
    uint neighbors = 0;

    BoidData self = src_boid_data.boids[current];

    for (int i = 0; i < boids_count; i++) {
        BoidData other = src_boid_data.boids[i];

        if (i == current || !is_visible(self, other.pos.xyz)) {continue;}
        neighbors += 1;

        steering += other.pos.xyz;
    }

    steering = average(steering, neighbors);

    vec3 desired = steering - self.pos.xyz;
    float d = length(desired);

    if (d > 0.0) {
        desired = normalize(desired);

        desired = damp(desired, d);

        steering = desired - self.vel.xyz;
    } else {
        steering = vec3(0.0);
    }

    return steering;
}

vec3 separation(uint current) {
    vec3 steering = vec3(0.0);
    uint neighbors = 0;

    BoidData self = src_boid_data.boids[current];

    for (int i = 0; i < boids_count; i++) {
        BoidData other = src_boid_data.boids[i];

        if (i == current || !is_visible(self, other.pos.xyz)) {continue;}
        neighbors += 1;

        steering += safe_normalize(self.pos.xyz - other.pos.xyz) / (distance(self.pos.xyz, other.pos.xyz) - 2.0 * BODY_RADIUS);
    }

    steering = average(steering, neighbors);

    return steering;
}

vec3 flock(uint current) {
    return wander(current) * 5.0 + cohesion(current) * 3.0 + align(current) * 2.0 + separation(current) * 7.0;
}

mat3 convert_velocity_to_rotation(vec3 vel) {
    vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 dir = safe_normalize(vel);
    vec3 side = safe_normalize(cross(dir, up));
    up = safe_normalize(cross(side, dir));
    return mat3(side, up, -dir); // use dir like a unit vector and set it to the direction the model is pointing
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    if (index >= boids_count) { return; }

    BoidData old_self = src_boid_data.boids[index];
    vec3 pos = old_self.pos.xyz;
    vec3 vel = old_self.vel.xyz;
    mat4 model = old_self.model;

    vec3 acc = flock(index) / WEIGHT;
    vec3 new_vel = limit(vel + acc * dt, MAX_VELOCITY);
    vec3 new_pos = pos + new_vel * dt;


    mat3 rotation = convert_velocity_to_rotation(new_vel);
    mat4 new_model = mat4(vec4(rotation[0], 0.0), vec4(rotation[1], 0.0), vec4(rotation[2], 0.0), vec4(new_pos, 1.0));

    dst_boid_data.boids[index].vel.xyz = new_vel;
    dst_boid_data.boids[index].pos.xyz = new_pos;
    dst_boid_data.boids[index].model = new_model;
}